#!/usr/bin/env escript
%% -*- mode: erlang -*-
%%! -smp auto
-module(mcu_emul).

-define(info(Msg), io:format("INFO: " ++ Msg)).
-define(info(Msg, Data), io:format("INFO: " ++ Msg, Data)).

-define(error(Msg), io:format("ERROR: " ++ Msg)).
-define(error(Msg, Data), io:format("ERROR: " ++ Msg, Data)).

-define(deps, ["getopt", "cereal"]).

-define(argspec, [
		  {help,    $h,        "help",    undefined,           "Show help"},
		  {num,     $n,        "num",     {integer, 1},        "MCU number"},
		  {pty,     undefined, undefined, string,              "Path to pty"}
		 ]).

main(Args) ->
    set_paths(),
    case getopt:parse(?argspec, Args) of
	{ok, {Opts, []}} ->
	    case proplists:get_bool(help, Opts) of
		true ->
		    getopt:usage(?argspec, atom_to_list(?MODULE)),
		    halt(0);
		false ->
		    start(Opts)
	    end;
	_ ->
	    getopt:usage(?argspec, atom_to_list(?MODULE)),
	    halt(1)
    end.

%%%
%%% Priv
%%%
start(Opts) ->
    case proplists:get_value(pty, Opts) of
	undefined ->
	    getopt:usage(?argspec, atom_to_list(?MODULE)),
	    halt(0);
	Pty ->
	    ?info("Opening ~p~n", [Pty]),
	    {ok, Fd} = cereal:open_tty(Pty),
	    ok = cereal:set_raw_tty_mode(Fd),
	    Port = open_port({fd, Fd, Fd}, [binary, stream, {line, 80}]),
	    loop(Port, proplists:get_value(num, Opts), <<>>)
    end.


loop(Port, N, Acc) ->
    receive
	{Port, {data, {noeol, Bin}}} ->
	    loop(Port, N, << Acc/binary, Bin/binary >>);
	{Port, {data, {eol, Bin}}} ->
	    handle_msg(bkfw_parser:parse_query(<< Acc/binary, Bin/binary >>), Port),
	    loop(Port, N, <<>>);
	_Else ->
	    ?error("received: ~p~n", [_Else]),
	    loop(Port, N, Acc)
    end.


handle_msg({error, Err}, _To) ->
    ?error("parse error: ~s~n", [Err]);
handle_msg(eof, _To) ->
    ok;
handle_msg({ok, _Addr, rcc, [Pos]}, To) when is_integer(Pos) ->
    reply(To, io_lib:format("CC ~p ~.2f mA", [Pos, 1230.32]));
handle_msg({ok, _Addr, scc, [Pos, Cur]}, To) when is_integer(Pos), is_float(Cur) ->
    reply(To, io_lib:format("SCC ~p ~.2f", [Pos, Cur]));
handle_msg({ok, _Addr, rgc, []}, To) ->
    reply(To, "GC 42.11 dB");
handle_msg({ok, _Addr, sgc, [Gain]}, To) when is_float(Gain) ->
    reply(To, io_lib:format("SGC ~.2f", [Gain]));
handle_msg({ok, _Addr, rpc, []}, To) ->
    reply(To, "PC 12.57 dBm");
handle_msg({ok, _Addr, spc, [Pow]}, To) ->
    reply(To, io_lib:format("SPC ~.2f", [Pow]));
handle_msg({ok, _Addr, rmode, []}, To) ->
    reply(To, "MODE CC");
handle_msg({ok, _Addr, smode, [Mode]}, To) when Mode == "PC";
						Mode == "GC";
						Mode == "CC";
						Mode == "OFF" ->
    reply(To, ["SMODE ", Mode]);
handle_msg({ok, _Addr, ra, []}, To) ->
    reply(To, "ALARMS: PUMP_TEMP BREF");
handle_msg({ok, _Addr, rlt, [Pos]}, To) when is_integer(Pos) ->
    reply(To, io_lib:format("LT ~p ~.2f C", [Pos, 89.99]));
handle_msg({ok, _Addr, rlc, [Pos]}, To) when is_integer(Pos) ->
    reply(To, io_lib:format("LC ~p ~.2f mA", [Pos, 234.32]));
handle_msg({ok, _Addr, rit, []}, To) ->
    reply(To, "IT 43.12 C");
handle_msg({ok, _Addr, ri, []}, To) ->
    reply(To, ["Vendor= Bktel Photonics\n",
	       "Module= blop\n",
	       "HW Ver= 0\n",
	       "HW Rev= A\n",
	       "SW Ver= 0.01\n",
	       "FW Ver= 0.01\n",
	       "Part Num= 123456\n",
	       "Ser. Num= 20141101001\n",
	       "Prod. Date= 20141101\n"]);
handle_msg({ok, _Addr, rpm, []}, To) ->
    reply(To, ["PD1 12.34 dBm\n",
	       "PD2 23.45 dBm\n",
	       "PD3 45.56 dBm\n"]);
handle_msg({ok, _Addr, rv, []}, To) ->
    reply(To, "V 24.0 V");
handle_msg({ok, _Addr, rli, []}, To) ->
    reply(To, "LI 89.01 dBm");
handle_msg({ok, _Addr, sli, [Pow]}, To) when is_float(Pow) ->
    reply(To, io_lib:format("SLI ~.2f", [Pow]));
handle_msg({ok, _Addr, rlo, []}, To) ->
    reply(To, "LO 12.78 dBm");
handle_msg({ok, _Addr, slo, [Loss]}, To) when is_float(Loss) ->
    reply(To, io_lib:format("SLO ~.2f", [Loss]));
handle_msg({ok, _Addr, Cmd, Args}, To) ->
    ?error("Invalid command: ~p(~p)~n", [Cmd, Args]),
    reply(To, "INVALID CMD").


reply(To, Ans) ->
    To ! {self(), {command, iolist_to_binary([Ans, "\n"])}}.


set_paths() ->
    Root = get_root(),
    Deps = lists:map(fun(D) -> 
			     Root ++ "/deps/" ++ D ++ "/ebin"
		     end, ?deps),
    code:add_pathsa([ Root ++ "/ebin" | Deps ]).

get_root() ->
    AbsName = filename:join(get_cwd(), escript:script_name()),
    [ _, _ | Root ] = lists:reverse(filename:split(AbsName)),
    filename:join(lists:reverse(Root)).

get_cwd() ->
    case file:get_cwd() of
	{ok, Dir} ->
	    Dir;
	{error, Reason} ->
	    ?error("Unable to get cwd: ~p~n", [Reason]),
	    halt(1)
    end.
