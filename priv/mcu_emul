#!/usr/bin/env escript
%% -*- mode: erlang -*-
%%! -smp auto
-module(mcu_emul).

-define(info(Msg), io:format("INFO: " ++ Msg)).
-define(info(Msg, Data), io:format("INFO: " ++ Msg, Data)).

-define(debug(Msg), io:format("DEBUG: " ++ Msg)).
-define(debug(Msg, Data), io:format("DEBUG: " ++ Msg, Data)).

-define(error(Msg), io:format("ERROR: " ++ Msg)).
-define(error(Msg, Data), io:format("ERROR: " ++ Msg, Data)).

-define(deps, ["getopt", "cereal"]).

-define(argspec, [
		  {help,    $h,        "help",    undefined,            "Show help"},
		  {slots,   $s,        "slots",   {string, "00000001"}, "MCU slots (8 chars hex)"},
		  {pty,     undefined, undefined, string,               "Path to pty"}
		 ]).

-define(mcu_alarms, {"PIN", "POUT", "PUMP_TEMP", "PUMP_BIAS", "BREF", "ADI", "MUTE"}).
-define(edfa_alarms, {"EDFA_TEMP", "EDFA_PSU"}).

-define(WAIT, true).
%-define(WAIT, timer:sleep(500)).

-record(mcu, {index              ,
	      ampConsign         ,
	      gainConsign        ,
	      outputPowerConsign ,
	      operatingMode      ,
	      curLaserTemp       ,
	      curAmp             ,
	      curInternalTemp    ,
	      powerPd1           ,
	      powerPd2           ,
	      powerPd3           ,
	      powerSupply        ,
	      inputLossThreshold ,
	      outputLossThreshold,
	      vendor             = "BKTel Photonics"        :: string(),
	      moduleType         = "MCU"                       :: string(),
	      hwVer              = ""                       :: string(),
	      hwRev              = ""                       :: string(),
	      swVer              = ""                       :: string(),
	      fwVer              = ""                       :: string(),
	      partNum            = ""                       :: string(),
	      serialNum          = ""                       :: string(),
	      productDate        = "20141201"                       :: string()
	     }).
-record(edfa, {
	  index=0,
	  internalTemp,
	  powerSupply,
	      vendor             = "BKTel Photonics"        :: string(),
	      moduleType         = "EDFA"                       :: string(),
	      hwVer              = "1.1"                       :: string(),
	      hwRev              = "B"                       :: string(),
	      swVer              = "1.1"                       :: string(),
	      fwVer              = "2014.12.11"                       :: string(),
	      partNum            = "1234"                       :: string(),
	      serialNum          = "20141012001"                       :: string(),
	      productDate        = "20141201"                       :: string()	  
	 }).
-record(state, {
	  port,
	  slots,
	  tid
	 }).

main(Args) ->
    set_paths(),
    case getopt:parse(?argspec, Args) of
	{ok, {Opts, []}} ->
	    case proplists:get_bool(help, Opts) of
		true ->
		    getopt:usage(?argspec, atom_to_list(?MODULE)),
		    halt(0);
		false ->
		    start(Opts)
	    end;
	_ ->
	    getopt:usage(?argspec, atom_to_list(?MODULE)),
	    halt(1)
    end.

%%%
%%% Priv
%%%
start(Opts) ->
    case proplists:get_value(pty, Opts) of
	undefined ->
	    getopt:usage(?argspec, atom_to_list(?MODULE)),
	    halt(0);
	Pty ->
	    ?info("Opening ~p~n", [Pty]),
	    {ok, Fd} = cereal:open_tty(Pty),
	    %ok = cereal:set_raw_tty_mode(Fd),
	    Port = open_port({fd, Fd, Fd}, [binary, stream, {line, 80}]),
	    Slots = list_to_binary(proplists:get_value(slots, Opts)),
	    ?info("Slots: ~.2b~n", [binary_to_integer(Slots, 16)]),
	    Tid = ets:new(emul, [{keypos, 2}]),
	    loop(#state{port=Port, slots=Slots, tid=Tid}, <<>>)
    end.


loop(#state{port=Port, tid=Tid}=S, Acc) ->
    receive
	{Port, {data, {noeol, Bin}}} ->
	    loop(S, << Acc/binary, Bin/binary >>);
	{Port, {data, {eol, Bin}}} ->
	    Msg = << Acc/binary, Bin/binary, $\r, $\n >>,
	    ?debug("received: ~p~n", [Msg]),
	    case bkfw_parser:parse(Msg) of
		{error, Err, _} ->
		    ?error("parse error: ~s~n", [Err]);
		{eof, _} ->
		    ok;
		{ok, {0, Cmd, Args}, _} ->
		    Obj = case ets:lookup(Tid, 0) of
			      [] ->
				  #edfa{internalTemp=random:uniform()*100,
					powerSupply=24.0};
			      [Edfa] -> Edfa
			  end,
		    ets:insert(Tid, handle_msg(Obj, Cmd, Args, S)),
		    loop(S, <<>>);
		{ok, {Idx, Cmd, Args}, _} ->
		    Obj = case ets:lookup(Tid, Idx) of
			      [] ->
				  #mcu{
				     index=Idx,
				     ampConsign=random:uniform()*100,
				     gainConsign=random:uniform()*100,
				     outputPowerConsign=random:uniform()*100,
				     operatingMode=element(random:uniform(4), {"PC", "GC", "CC", "OFF"}),
				     curLaserTemp=random:uniform()*100,
				     curAmp=random:uniform()*100,
				     curInternalTemp=random:uniform()*100,
				     powerPd1=random:uniform()*100 * element(random:uniform(2), {1,-1}),
				     powerPd2=random:uniform()*100 * element(random:uniform(2), {1,-1}),
				     powerPd3=random:uniform()*100 * element(random:uniform(2), {1,-1}),
				     powerSupply=12.0,
				     inputLossThreshold=random:uniform()*100,
				     outputLossThreshold=random:uniform()*100,
				     hwVer=element(random:uniform(3), {"1.1", "1.0", "1.2"}),
				     swVer=element(random:uniform(3), {"0.1", "0.2", "0.3"}),
				     fwVer=element(random:uniform(3), {"0.1a", "0.1b", "0.2.0"}),
				     partNum=element(random:uniform(2), {"123", "456"}),
				     serialNum=io_lib:format("~b", [random:uniform(1000)])
				    };
			      [Edfa] -> Edfa
			  end,
		    {S2, Obj2} = handle_msg(Obj, Cmd, Args, S),
		    ets:insert(Tid, Obj2),
		    loop(S2, <<>>)
	    end;
	_Else ->
	    ?error("received: ~p~n", [_Else]),
	    loop(S, Acc)
    end.

handle_msg(#mcu{index=Addr}=Mcu, rcc, [Pos], #state{port=To}=S) when is_integer(Pos) ->
    reply(To, Addr, io_lib:format("CC ~p ~.2f mA", [Pos, Mcu#mcu.ampConsign])),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, scc, [Pos, Cur], #state{port=To}=S) when is_integer(Pos), is_float(Cur) ->
    reply(To, Addr, io_lib:format("SCC ~p ~.2f", [Pos, Cur])),
    {S, Mcu#mcu{ampConsign=Cur}};

handle_msg(#mcu{index=Addr}=Mcu, rgc, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("GC ~.2f dB", [Mcu#mcu.gainConsign])),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, sgc, [Gain], #state{port=To}=S) when is_float(Gain) ->
    reply(To, Addr, io_lib:format("SGC ~.2f", [Gain])),
    {S, Mcu#mcu{gainConsign=Gain}};

handle_msg(#mcu{index=Addr}=Mcu, rpc, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("PC ~.2f dBm", [Mcu#mcu.outputPowerConsign])),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, spc, [Pow], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("SPC ~.2f", [Pow])),
    {S, Mcu#mcu{outputPowerConsign=Pow}};

handle_msg(#mcu{index=Addr}=Mcu, rmode, [], #state{port=To}=S) ->
    reply(To, Addr, ["MODE ", Mcu#mcu.operatingMode]),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, smode, [Mode], #state{port=To}=S) when Mode == pc;
									Mode == gc;
									Mode == cc;
									Mode == off ->
    ModeStr = mode_to_list(Mode),
    reply(To, Addr, ["SMODE ", ModeStr]),
    {S, Mcu#mcu{operatingMode=ModeStr}};

handle_msg(#edfa{}=Edfa, ra, [], #state{port=To}=S) ->
    case random:uniform(4) of
	1 ->
	    Alarm = element(random:uniform(size(?edfa_alarms)), ?edfa_alarms),
	    reply(To, 0, ["ALARMS: ", Alarm]);
	_ ->
	    reply(To, 0, "ALARMS:")
    end,
    {S, Edfa};

handle_msg(#mcu{index=Addr}=Mcu, ra, [], #state{port=To}=S) ->
    case random:uniform(4) of
	%1 ->
	%    Alarm = element(random:uniform(size(?mcu_alarms)), ?mcu_alarms),
	%    reply(To, Addr, ["ALARMS: ", Alarm]);
	%_ ->
	%    reply(To, Addr, "ALARMS:")
	_ -> reply(To, Addr, "ALARMS: EDFA_TEMP")
    end,
    {S, Mcu};

handle_msg(#mcu{index=Addr, curLaserTemp=LT}=Mcu, rlt, [Pos], #state{port=To}=S) when is_integer(Pos) ->
    reply(To, Addr, io_lib:format("LT ~p ~.2f C", [Pos, LT])),
    {S, Mcu#mcu{curLaserTemp=ran(LT)}};

handle_msg(#mcu{index=Addr, curAmp=LC}=Mcu, rlc, [Pos], #state{port=To}=S) when is_integer(Pos) ->
    reply(To, Addr, io_lib:format("LC ~p ~.2f mA", [Pos, LC])),
    {S, Mcu#mcu{curAmp=ran(LC)}};

handle_msg(#edfa{internalTemp=IT}=Edfa, rit, [], #state{port=To}=S) ->
    reply(To, 0, io_lib:format("IT ~.2f C", [IT])),
    {S, Edfa#edfa{internalTemp=ran(IT)}};

handle_msg(#mcu{index=Addr, curInternalTemp=IT}=Mcu, rit, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("IT ~.2f C", [IT])),
    {S, Mcu#mcu{curInternalTemp=ran(IT)}};

handle_msg(#edfa{}=Edfa, ri, [], #state{port=To}=S) ->
    reply(To, 0, ["I", $\r, $\n, $\r, $\n, 
		  "Vendor= ", Edfa#edfa.vendor, $\r, $\n, $\r, $\n, 
		     "Module= ", Edfa#edfa.moduleType, $\r, $\n, $\r, $\n,
		     "HW Ver= ", Edfa#edfa.hwVer, $\r, $\n, $\r, $\n,
		     "HW Rev= ", Edfa#edfa.hwRev, $\r, $\n, $\r, $\n,
		     "SW Ver= ", Edfa#edfa.swVer, $\r, $\n, $\r, $\n,
		     "FW Ver= ", Edfa#edfa.fwVer, $\r, $\n, $\r, $\n,
		     "Part Num= ", Edfa#edfa.partNum, $\r, $\n, $\r, $\n,
		     "Ser. Num= ", Edfa#edfa.serialNum, $\r, $\n, $\r, $\n,
		     "Prod. Date= ", Edfa#edfa.productDate, $\r, $\n, $\r, $\n]),
    {S, Edfa};

handle_msg(#mcu{index=Addr}=Mcu, ri, [], #state{port=To}=S) ->
    reply(To, Addr, ["I", $\r, $\n, $\r, $\n,
		     "Vendor= ", Mcu#mcu.vendor, $\r, $\n, $\r, $\n,
		     "Module= ", Mcu#mcu.moduleType, $\r, $\n, $\r, $\n,
		     "HW Ver= ", Mcu#mcu.hwVer, $\r, $\n, $\r, $\n,
		     "HW Rev= ", Mcu#mcu.hwRev, $\r, $\n, $\r, $\n,
		     "SW Ver= ", Mcu#mcu.swVer, $\r, $\n, $\r, $\n,
		     "FW Ver= ", Mcu#mcu.fwVer, $\r, $\n, $\r, $\n,
		     "Part Num= ", Mcu#mcu.partNum, $\r, $\n, $\r, $\n,
		     "Ser. Num= ", Mcu#mcu.serialNum, $\r, $\n, $\r, $\n,
		     "Prod. Date= ", Mcu#mcu.productDate, $\r, $\n, $\r, $\n]),
    {S, Mcu};

handle_msg(#mcu{index=Addr, powerPd1=PD1, powerPd2=PD2}=Mcu, rpm, [], #state{port=To}=S) ->
    reply(To, Addr, [io_lib:format("PD1 ~.2f dBm", [PD1]), $\r, $\n, $\r, $\n,
		     io_lib:format("PD2 ~.2f dBm", [PD2]), $\r, $\n, $\r, $\n]),
    {S, Mcu#mcu{powerPd1=ran(PD1), powerPd2=ran(PD2)}};

handle_msg(#edfa{index=Addr, powerSupply=V}=Edfa, rv, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("V ~.2f V", [V])),
    {S, Edfa#edfa{powerSupply=ran(V)}};

handle_msg(#mcu{index=Addr, powerSupply=V}=Mcu, rv, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("V ~.2f V", [V])),
    {S, Mcu#mcu{powerSupply=ran(V)}};

handle_msg(#mcu{index=Addr}=Mcu, rli, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("LI ~.2f dBm", [Mcu#mcu.inputLossThreshold])),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, sli, [Pow], #state{port=To}=S) when is_float(Pow) ->
    reply(To, Addr, io_lib:format("SLI ~.2f", [Pow])),
    {S, Mcu#mcu{inputLossThreshold=Pow}};

handle_msg(#mcu{index=Addr}=Mcu, rlo, [], #state{port=To}=S) ->
    reply(To, Addr, io_lib:format("LO ~.2f dBm", [Mcu#mcu.outputLossThreshold])),
    {S, Mcu};

handle_msg(#mcu{index=Addr}=Mcu, slo, [Loss], #state{port=To}=S) when is_float(Loss) ->
    reply(To, Addr, io_lib:format("SLO ~.2f", [Loss])),
    {S, Mcu#mcu{outputLossThreshold=Loss}};

handle_msg(#edfa{}=Edfa, rn, [], #state{port=To, slots=Slots}=S) ->
    reply(To, 0, ["N 0x", Slots]),
    {S, Edfa};

handle_msg(#edfa{}=Edfa, Cmd, Args, #state{port=To}=S) ->
    ?error("Invalid command: ~p(~p)~n", [Cmd, Args]),
    reply(To, 0, "INVALID CMD"),
    {S, Edfa};

handle_msg(#mcu{index=Addr}=Mcu, Cmd, Args, #state{port=To}=S) ->
    ?error("Invalid command: ~p(~p)~n", [Cmd, Args]),
    reply(To, Addr, "INVALID CMD"),
    {S, Mcu}.


reply(To, Addr, Ans) ->
    ?WAIT,
    HexAddr = ["0x", io_lib:format("~2.16.0b", [Addr])],
    Msg = iolist_to_binary([HexAddr, " ", Ans, $\r, $\n, $\r, $\n]),
    ?debug("replying: ~p~n", [Msg]),
    To ! {self(), {command, Msg}}.


set_paths() ->
    Root = get_root(),
    Deps = lists:map(fun(D) -> 
			     Root ++ "/deps/" ++ D ++ "/ebin"
		     end, ?deps),
    code:add_pathsa([ Root ++ "/ebin" | Deps ]).

get_root() ->
    AbsName = filename:join(get_cwd(), escript:script_name()),
    [ _, _ | Root ] = lists:reverse(filename:split(AbsName)),
    filename:join(lists:reverse(Root)).

get_cwd() ->
    case file:get_cwd() of
	{ok, Dir} ->
	    Dir;
	{error, Reason} ->
	    ?error("Unable to get cwd: ~p~n", [Reason]),
	    halt(1)
    end.

mode_to_list(pc) -> "PC";
mode_to_list(gc) -> "GC";
mode_to_list(cc) -> "CC";
mode_to_list(off) -> "OFF".

ran(V) ->
    V * (random:uniform()+0.5).
